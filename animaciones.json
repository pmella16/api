[
    {
      "id": "3",
      "type": "trippy",
      "code": "float E = 2.7182818284;\n float GR = 1.61803398875;\n float EPS = 0.001;\n \n float MAX_DIM = 3000.0;\n \n vec3 flux(float x) {\n return (vec3(cos(x),cos(4.0*M_PI/3.0+x),cos(2.0*M_PI/3.0+x))*.5+.5);\n }\n \n float saw(float x)\n {\n float f = mod(floor(abs(x)), 2.0);\n float m = mod(abs(x), 1.0);\n return f*(1.0-m)+(1.0-f)*m;\n }\n vec2 saw(vec2 x)\n {\n return vec2(saw(x.x), saw(x.y));\n }\n \n vec3 saw(vec3 x)\n {\n return vec3(saw(x.x), saw(x.y), saw(x.z));\n }\n float time() {\n return ((saw(float(11)/GR)+1.0)*(iTime/E+1234.4321)/E);\n }\n float cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n \n vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n {\n vec2 res = vec2(-1.0);\n \n vec2 e = b-a;\n vec2 f = d-a;\n vec2 g = a-b+c-d;\n vec2 h = p-a;\n \n float k2 = cross2d( g, f );\n float k1 = cross2d( e, f ) + cross2d( h, g );\n float k0 = cross2d( h, e );\n \n if( abs(k2)<0.001 )\n {\n float v = -k0/k1;\n float u = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n res = vec2( u, v );\n }\n else\n {\n float w = k1*k1 - 4.0*k0*k2;\n w = sqrt( w );\n \n float ik2 = 0.5/k2;\n float v = (-k1 - w)*ik2;\n float u = (h.x - f.x*v)/(e.x + g.x*v);\n res = vec2( u, v );\n }\n return (res);\n }\n \n \n mat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n \n \n float smooth_floor(float x)\n {\n return floor(x)+smoothstep(.75, 1., fract(x));\n }\n \n vec2 tree(vec2 uv)\n {\n \n vec2 p = uv*2.-1.;\n \n \n float angle = smooth_floor((time()))*M_PI/12.;\n \n vec2 a = vec2(1., 1.);\n vec2 b = vec2(0., 1.);\n vec2 c = vec2(0., 0.);\n vec2 d = vec2(1., 1./MAX_DIM);\n vec2 s = vec2(.75);\n vec2 o = vec2(smooth_floor(time()/M_PI)/500., 0.);\n mat2 m = rotate(angle);\n a = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n a = a*m; b = b*m; c = c*m; d = d*m;\n a *= s; b *= s; c *= s; d *= s;\n a += o; b += o; c += o; d += o;\n vec2 a2 = a*vec2(-1., 1.);\n vec2 b2 = b*vec2(-1., 1.);\n vec2 c2 = c*vec2(-1., 1.);\n vec2 d2 = d*vec2(-1., 1.);\n if(p.x > 0.)\n p = (invBilinear( p, a, b, c, d ));\n else\n p = (invBilinear( p, a2, b2, c2, d2 ));\n return p;\n }\n \n vec2 flower(vec2 p)\n {\n p *= rotate(time());\n float rots = smooth_floor(3.+6.*saw(time()/E))+1./MAX_DIM;\n float angle = atan(-p.y, -p.x);\n float radius = length(p);\n angle = floor(((angle/M_PI)*.5+.5)*rots);\n \n \n vec2 a = vec2(1., 0.);\n vec2 b = vec2(1., 1./MAX_DIM);\n vec2 c = vec2(0., 1./MAX_DIM);\n vec2 d = vec2(0., -1./MAX_DIM);\n \n b *= rotate(angle/rots*2.*M_PI);\n angle += 1.;\n a *= rotate(angle/rots*2.*M_PI);\n \n return (invBilinear( p, a, b, c, d ));\n }\n \n \n float square(vec2 uv, vec2 uv0)\n {\n uv = (uv*2.-1.)*GR;\n return abs(saw(uv.y+uv0.x-uv0.y+time())-uv.x);\n }\n \n \n vec2 sM_piral(vec2 uv)\n {\n float r = log(length(uv)+1.)/2.;\n float theta = atan(uv.y, uv.x)/M_PI-r*sin(time()/E/M_PI/GR)/M_PI;\n return vec2(saw(r+time()/E/E),\n saw(theta+time()/GR/E))*2.-1.;\n }\n \n vec3 phase(float map)\n {\n return vec3(sin(map),\n sin(4.0*M_PI/3.0+map),\n sin(2.0*M_PI/3.0+map))*.5+.5;\n }\n \n half4 main(vec2 fragCoord) { \n vec2 uv = fragCoord.xy/iResolution.xy;\n vec2 uv0 = uv.xy*2.-1.;\n uv0.x *= max(iResolution.x/iResolution.y, 1.);\n uv0.y *= max(iResolution.y/iResolution.x, 1.);\n uv0 = uv0*.5+.5;\n float map = 0.0;\n vec4 fragColor;\n \n float lambda = 4.0;\n const int max_iterations = 12;\n \n float scale = 3.0*M_PI+(iTime*M_PI*GR*E);\n uv *= scale;\n uv -= scale/2.0;\n uv.x *= max(iResolution.x/iResolution.y, 1.);\n uv.y *= max(iResolution.y/iResolution.x, 1.);\n uv.xy += vec2(cos(iTime*.234),\n sin(iTime*.345))*scale/2.;\n float m = smoothstep(0.45, .55, saw(iTime/E/M_PI));\n uv.xy = sM_piral(uv.xy*scale)*m+(1.-m)*(uv0);;\n \n float nature = smoothstep(.45, .55, saw(iTime/GR/E))*(1.-m);\n uv = uv*(1.-nature)+flower(uv0*2.-1.)*nature;\n \n for(int i = 0; i <= max_iterations; i++)\n {\n float iteration = (float(i)/(float(max_iterations) ));\n uv.xy = saw(tree(uv.xy));\n map += square(uv.xy, uv0);\n uv0 = uv;\n }\n \n float w = smoothstep(saw(map/float(max_iterations)+iTime), .0, .2);\n float b = smoothstep(saw(map/float(max_iterations)+iTime), .0, .2);\n fragColor.rgb = (flux(map))*\n \n clamp(map, 0.0, 1.0);\n fragColor.a = 1.0;\n return fragColor;\n }\n "
    },
    {
      "id": "4",
      "type": "color",
      "code": "half4 main(vec2 u) { \n vec4 o;\n o = vec4(u,iTime*9.,0);\n for ( int i=0; i<96; i++)\n o = abs( o/dot(o,o)-.9 );\n return o;\n }"
    },
    {
      "id": "14",
      "type": "trippy",
      "code": "float mytanh(float x) {\n return (exp(2.0 * x) - 1.0) / (exp(2.0 * x) + 1.0);\n }\n float thc(float a, float b) {\n return mytanh(a * cos(b)) / mytanh(a);\n }\n \n vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n {\n return a + b*cos( 6.28318*(c*t+d) );\n }\n \n float h21 (vec2 a) {\n return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n }\n \n half4 main(vec2 fragCoord) { \n vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n float r = length(uv);\n \n \n \n float k = 10. + 8. * thc(3., r + iTime);\n float sc = 6. * ceil(k * fract(abs(uv.y) + r - 0.2 * iTime));\n float d = length(floor(sc * uv) + 0.5)/sc;\n float s = smoothstep(-1., 0.5, 0.1 + 0.5 * h21(uv));\n \n \n vec3 col = 1.1 * s * pal(d * 33333. + r - iTime * 0.1, \n vec3(1.), vec3(1.), vec3(1.), vec3(0.,0.33,0.66));\n \n return vec4(col,1.0);\n }"
    },
    {
      "id": "18",
      "type": "loop",
      "code": "float vDrop(vec2 uv,float t)\n {\n uv.x = uv.x*128.0;\t\t\t\t\t\t\n float dx = fract(uv.x);\n uv.x = floor(uv.x);\n uv.y *= 0.05;\t\t\t\t\t\t\t\n float o=sin(uv.x*215.4);\t\t\t\t\n float s=cos(uv.x*33.1)*.3 +.7;\t\t\t\n float trail = mix(95.0,35.0,s);\t\t\t\n float yv = fract(uv.y + t*s + o) * trail;\n yv = 1.0/yv;\n yv = smoothstep(0.0,1.0,yv*yv);\n yv = sin(yv*M_PI)*(s*5.0);\n float d2 = sin(dx*M_PI);\n return yv*(d2*d2);\n }\n \n \n half4 main(vec2 fragCoord) { \n vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n float d = length(p)+exp(-iTime)*0.9+0.1;\n p = vec2(atan(p.x, p.y) / M_PI, 2.5 / d);\n float t = iTime*0.4;\n vec3 col = vec3(1.55,0.65,.225) * vDrop(p,t);\t\n col += vec3(0.55,0.75,1.225) * vDrop(p,t+0.33);\t\n col += vec3(0.45,1.15,0.425) * vDrop(p,t+0.66);\t\n return vec4(col*(d*d), 1.0);\n }\n "
    },
    {
      "id": "21",
      "type": "trippy",
      "code": "const float PI = 3.141592654; const float TAU = (2.0 * PI); \n\n float L2(vec3 x) {\n return dot(x, x);\n }\n \n mat2 ROT(float a) {\n return mat2(cos(a), sin(a), -sin(a), cos(a));\n }\n \n \n float PSIN(float x) {\n return (0.5 + 0.5 * sin(x));\n }\n \n float myTanh(float x) {\n return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n }\n \n vec3 hsv2rgb(vec3 c) {\n const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n }\n \n float apollian(vec4 p, float s) {\n float scale = 1.0;\n \n for(int i=0; i<7; ++i) {\n p = -1.0 + 2.0*fract(0.5*p+0.5);\n \n float r2 = dot(p,p);\n \n float k = s/r2;\n p *= k;\n scale *= k;\n }\n \n return abs(p.y)/scale;\n }\n \n float weird(vec2 p) {\n float z = 4.0;\n p *= ROT(iTime*0.1);\n float tm = 0.2*iTime;\n float r = 0.5;\n vec4 off = vec4(r*PSIN(tm*sqrt(3.0)), r*PSIN(tm*sqrt(1.5)), r*PSIN(tm*sqrt(2.0)), 0.0);\n vec4 pp = vec4(p.x, p.y, 0.0, 0.0)+off;\n pp.w = 0.125*(1.0-myTanh(length(pp.xyz)));\n pp.yz *= ROT(tm);\n pp.xz *= ROT(tm*sqrt(0.5));\n pp /= z;\n float d = apollian(pp, 1.2);\n return d*z;\n }\n \n float df(vec2 p) {\n const float zoom = 0.5;\n p /= zoom;\n float d0 = weird(p);\n return d0*zoom;\n }\n \n vec3 color(vec2 p) {\n float aa = 2.0/iResolution.y;\n const float lw = 0.0235;\n const float lh = 1.25;\n \n const vec3 lp1 = vec3(0.5, lh, 0.5);\n const vec3 lp2 = vec3(-0.5, lh, 0.5);\n \n float d = df(p);\n \n float b = -0.125;\n float t = 10.0;\n \n vec3 ro = vec3(0.0, t, 0.0);\n vec3 pp = vec3(p.x, 0.0, p.y);\n \n vec3 rd = normalize(pp - ro);\n \n vec3 ld1 = normalize(lp1 - pp);\n vec3 ld2 = normalize(lp2 - pp);\n \n float bt = -(t-b)/rd.y;\n \n vec3 bp = ro + bt*rd;\n vec3 srd1 = normalize(lp1-bp);\n vec3 srd2 = normalize(lp2-bp);\n float bl21= L2(lp1-bp);\n float bl22= L2(lp2-bp);\n \n float st1= (0.0-b)/srd1.y;\n float st2= (0.0-b)/srd2.y;\n vec3 sp1 = bp + srd1*st1;\n vec3 sp2 = bp + srd2*st1;\n \n float bd = df(bp.xz);\n float sd1= df(sp1.xz);\n float sd2= df(sp2.xz);\n \n vec3 col = vec3(0.0);\n const float ss =15.0;\n \n col += vec3(1.0, 1.0, 1.0)*(1.0-exp(-ss*(max((sd1+0.0*lw), 0.0))))/bl21;\n col += vec3(0.5)*(1.0-exp(-ss*(max((sd2+0.0*lw), 0.0))))/bl22;\n float l = length(p);\n float hue = fract(0.75*l-0.3*iTime)+0.3+0.15;\n float sat = 0.75*myTanh(2.0*l);\n vec3 hsv = vec3(hue, sat, 1.0);\n vec3 bcol = hsv2rgb(hsv);\n col *= (1.0-myTanh(0.75*l))*0.5;\n col = mix(col, bcol, smoothstep(-aa, aa, -d)); \n col += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*myTanh(l))*max(d, 0.0)));\n \n return col;\n }\n \n vec3 postProcess(vec3 col, vec2 q) {\n col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n col=col*0.6+0.4*col*col*(3.0-2.0*col); \n col=mix(col, vec3(dot(col, vec3(0.33))), -0.4); \n col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7); \n return col;\n }\n \n half4 main(vec2 fragCoord) { \n vec2 q = fragCoord/iResolution.xy;\n vec2 p = -1. + 2. * q;\n p.x *= iResolution.x/iResolution.y;\n \n vec3 col = color(p);\n col = postProcess(col, q);\n \n return vec4(col, 1.0);\n }"
    },
    {
      "id": "23",
      "type": "trippy",
      "code": "float rand(float n){return fract(sin(n) * 43758.5453123);}\n float rand(vec2 n){return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n float noise(float p){\n float fl = floor(p);\n float fc = fract(p);\n return mix(rand(fl), rand(fl + 1.0), fc);\n }\n \n \n vec3 hsv2rgb(vec3 c)\n {\n vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n }\n \n float manh_distance(vec2 a, vec2 b) {\n vec2 c = abs(a - b);\n return c.x + c.y;\n }\n \n float pyramids(vec2 p)\n {\n vec2 n = floor(p);\n vec2 f = fract(p);\n float mind = 2.0;\n for (int i=-1;i<2;i++)\n for (int j=-1;j<2;j++)\n {\n vec2 off = vec2(i,j);\n vec2 top = vec2( rand(n+off), rand(n+off+234.1) );\n float dist = manh_distance(f,top+off);\n if (dist < mind) {\n mind = dist;\n }\n }\n return (2.0 - mind) / 2.0;\n }\n \n float SQ3 = 1.7320508076;\n \n mat2 rot2d(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n \n vec2 p6mmmap(vec2 uv, float repeats) {\n \n uv.x /= SQ3;\n uv = fract(uv * repeats - 0.5) - 0.5;\n uv.x *= SQ3;\n \n uv = abs(uv);\n \n vec2 st = uv;\n \n vec2 uv330 = rot2d(radians(330.)) * uv;\n if (uv330.x < 0.0){\n st.y = (st.y - 0.5) * -1.0;\n st.x *= SQ3;\n return st * 2.0;\n }\n else if (uv330.x > 0.5){\n st.x = (st.x - 0.5 * SQ3) * -1.0 * SQ3;\n return st * 2.0;\n }\n \n vec2 uv30 = rot2d(radians(30.)) * uv;\n if (uv30.y < 0.0 && uv30.x >= 0.5) st = vec2(1.0,1.0);\n else if (uv30.y >= 0.0 && uv30.x >= 0.5) st = vec2(-1.0,1.0);\n else if (uv30.y < 0.0 && uv30.x < 0.5) st = vec2(1.0,-1.0);\n else st = vec2(-1.0,-1.0);\n \n uv30.x = uv30.x - 0.5;\n uv = rot2d(radians(270.))* uv30;\n st = uv * st;\n st.x *= SQ3;\n return st * 2.0;\n }\n \n float uc(float a) { return clamp(a,0.,1.); }\n float ns(float a, float t) { return noise(a+t); }\n \n vec3 square_noise(vec2 uv, float t) {\n \n float p1 = ns(pyramids(uv)*15.,t);\n float p2 = ns(pyramids(uv+135.)*31.,t);\n float p3 = ns(pyramids(uv+25.)*63.,t);\n \n float v = uc((p1*p2*p3-0.09)*41.);\n \n vec3 res = hsv2rgb(vec3(uc(uc(p3)-0.2),uc(uc(p2)-0.2),v));\n \n return res;\n }\n \n vec4 animate_noise(vec2 uv, float t) {\n return vec4(square_noise((rot2d(radians(t*12.7))*(uv-0.25)+0.25)+t*0.06,t*0.2),1.0);\n }\n \n \n half4 main(vec2 fragCoord) { \n \n vec2 uv = fragCoord / iResolution.xy - 0.5;\n uv.x *= iResolution.x/iResolution.y;\n uv *= iResolution.x / 2000.0;\n \n uv = p6mmmap(uv,2.) * 0.65;\n \n float t = floor(0/10.)*4.+4.*iResolution.x/10.*floor(0/10.)-100000.;\n return animate_noise(uv,t>-100000. ? t : iTime);\n }"
    }
  ]
  