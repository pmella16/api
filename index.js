
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const morgan = require('morgan');

const fs = require('fs');

const app = express();
const PORT = 5555;
const MAX_FILE_SIZE = 1000;


//add other middleware
app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({extended: true}));
app.use(morgan('dev'));


app.use(bodyParser.raw({ type: 'application/octet-stream', limit: '1000mb' }));

app.get('/musica', async (req, res, next) => {

  const data = [ 
    { "name": "Alpha_Team", "category": "Electronic", "file": "Alpha_Team.mp3" }, 
    { "name": "Slick_Clothes", "category": "House", "file": "Slick_Clothes.mp3" }, 
    { "name": "SynthWorld_Mono_Lines", "category": "Synthwave", "file": "SynthWorld_Mono_Lines.mp3" }, 
    { "name": "Astral_Injection", "category": "Trance", "file": "Astral_Injection.mp3" }, 
    { "name": "Chakra", "category": "Energetic", "file": "Chakra.mp3" }, 
    { "name": "TechHouse_Masters", "category": "TechHouse", "file": "TechHouse_Masters.mp3" }, 
    { "name": "Vaporwave", "category": "Dreamy", "file": "Vaporwave.mp3" } 
  ]

  res.send(data);
});

app.get('/animaciones', (req, res) => {
  res.send([{"id":"3","type":"trippy","code":"float E = 2.7182818284;\n float GR = 1.61803398875;\n float EPS = 0.001;\n \n float MAX_DIM = 3000.0;\n \n vec3 flux(float x) {\n return (vec3(cos(x),cos(4.0*M_PI/3.0+x),cos(2.0*M_PI/3.0+x))*.5+.5);\n }\n \n float saw(float x)\n {\n float f = mod(floor(abs(x)), 2.0);\n float m = mod(abs(x), 1.0);\n return f*(1.0-m)+(1.0-f)*m;\n }\n vec2 saw(vec2 x)\n {\n return vec2(saw(x.x), saw(x.y));\n }\n \n vec3 saw(vec3 x)\n {\n return vec3(saw(x.x), saw(x.y), saw(x.z));\n }\n float time() {\n return ((saw(float(11)/GR)+1.0)*(iTime/E+1234.4321)/E);\n }\n float cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n \n vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n {\n vec2 res = vec2(-1.0);\n \n vec2 e = b-a;\n vec2 f = d-a;\n vec2 g = a-b+c-d;\n vec2 h = p-a;\n \n float k2 = cross2d( g, f );\n float k1 = cross2d( e, f ) + cross2d( h, g );\n float k0 = cross2d( h, e );\n \n if( abs(k2)<0.001 )\n {\n float v = -k0/k1;\n float u = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n res = vec2( u, v );\n }\n else\n {\n float w = k1*k1 - 4.0*k0*k2;\n w = sqrt( w );\n \n float ik2 = 0.5/k2;\n float v = (-k1 - w)*ik2;\n float u = (h.x - f.x*v)/(e.x + g.x*v);\n res = vec2( u, v );\n }\n return (res);\n }\n \n \n mat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n \n \n float smooth_floor(float x)\n {\n return floor(x)+smoothstep(.75, 1., fract(x));\n }\n \n vec2 tree(vec2 uv)\n {\n \n vec2 p = uv*2.-1.;\n \n \n float angle = smooth_floor((time()))*M_PI/12.;\n \n vec2 a = vec2(1., 1.);\n vec2 b = vec2(0., 1.);\n vec2 c = vec2(0., 0.);\n vec2 d = vec2(1., 1./MAX_DIM);\n vec2 s = vec2(.75);\n vec2 o = vec2(smooth_floor(time()/M_PI)/500., 0.);\n mat2 m = rotate(angle);\n a = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n a = a*m; b = b*m; c = c*m; d = d*m;\n a *= s; b *= s; c *= s; d *= s;\n a += o; b += o; c += o; d += o;\n vec2 a2 = a*vec2(-1., 1.);\n vec2 b2 = b*vec2(-1., 1.);\n vec2 c2 = c*vec2(-1., 1.);\n vec2 d2 = d*vec2(-1., 1.);\n if(p.x > 0.)\n p = (invBilinear( p, a, b, c, d ));\n else\n p = (invBilinear( p, a2, b2, c2, d2 ));\n return p;\n }\n \n vec2 flower(vec2 p)\n {\n p *= rotate(time());\n float rots = smooth_floor(3.+6.*saw(time()/E))+1./MAX_DIM;\n float angle = atan(-p.y, -p.x);\n float radius = length(p);\n angle = floor(((angle/M_PI)*.5+.5)*rots);\n \n \n vec2 a = vec2(1., 0.);\n vec2 b = vec2(1., 1./MAX_DIM);\n vec2 c = vec2(0., 1./MAX_DIM);\n vec2 d = vec2(0., -1./MAX_DIM);\n \n b *= rotate(angle/rots*2.*M_PI);\n angle += 1.;\n a *= rotate(angle/rots*2.*M_PI);\n \n return (invBilinear( p, a, b, c, d ));\n }\n \n \n float square(vec2 uv, vec2 uv0)\n {\n uv = (uv*2.-1.)*GR;\n return abs(saw(uv.y+uv0.x-uv0.y+time())-uv.x);\n }\n \n \n vec2 sM_piral(vec2 uv)\n {\n float r = log(length(uv)+1.)/2.;\n float theta = atan(uv.y, uv.x)/M_PI-r*sin(time()/E/M_PI/GR)/M_PI;\n return vec2(saw(r+time()/E/E),\n saw(theta+time()/GR/E))*2.-1.;\n }\n \n vec3 phase(float map)\n {\n return vec3(sin(map),\n sin(4.0*M_PI/3.0+map),\n sin(2.0*M_PI/3.0+map))*.5+.5;\n }\n \n half4 main(vec2 fragCoord) { \n vec2 uv = fragCoord.xy/iResolution.xy;\n vec2 uv0 = uv.xy*2.-1.;\n uv0.x *= max(iResolution.x/iResolution.y, 1.);\n uv0.y *= max(iResolution.y/iResolution.x, 1.);\n uv0 = uv0*.5+.5;\n float map = 0.0;\n vec4 fragColor;\n \n float lambda = 4.0;\n const int max_iterations = 12;\n \n float scale = 3.0*M_PI+(iTime*M_PI*GR*E);\n uv *= scale;\n uv -= scale/2.0;\n uv.x *= max(iResolution.x/iResolution.y, 1.);\n uv.y *= max(iResolution.y/iResolution.x, 1.);\n uv.xy += vec2(cos(iTime*.234),\n sin(iTime*.345))*scale/2.;\n float m = smoothstep(0.45, .55, saw(iTime/E/M_PI));\n uv.xy = sM_piral(uv.xy*scale)*m+(1.-m)*(uv0);;\n \n float nature = smoothstep(.45, .55, saw(iTime/GR/E))*(1.-m);\n uv = uv*(1.-nature)+flower(uv0*2.-1.)*nature;\n \n for(int i = 0; i <= max_iterations; i++)\n {\n float iteration = (float(i)/(float(max_iterations) ));\n uv.xy = saw(tree(uv.xy));\n map += square(uv.xy, uv0);\n uv0 = uv;\n }\n \n float w = smoothstep(saw(map/float(max_iterations)+iTime), .0, .2);\n float b = smoothstep(saw(map/float(max_iterations)+iTime), .0, .2);\n fragColor.rgb = (flux(map))*\n \n clamp(map, 0.0, 1.0);\n fragColor.a = 1.0;\n return fragColor;\n }\n "},{"id":"4","type":"color","code":"half4 main(vec2 u) { \n vec4 o;\n o = vec4(u,iTime*9.,0);\n for ( int i=0; i<96; i++)\n o = abs( o/dot(o,o)-.9 );\n return o;\n }"},{"id":"5","type":"trippy","code":"float scale = 5.;\n\n\n float hash( float n ) {\n return fract(sin(n)*43758.5453);\n }\n \n \n \n \n vec2 hash12( float n ) {\n return fract(sin(n+vec2(1.,12.345))*43758.5453);\n }\n float hash21( vec2 n ) {\n return hash(n.x+10.*n.y);\n }\n vec2 hash22( vec2 n ) {\n return hash12(n.x+10.*n.y);\n }\n \n float cell; \n vec2 center; \n \n vec3 worley( vec2 p ) {\n vec3 d = vec3(1e15);\n vec2 ip = floor(p);\n for (float i=-2.; i<3.; i++)\n for (float j=-2.; j<3.; j++) {\n vec2 p0 = ip+vec2(i,j);\n float a0 = hash21(p0), a=5.*a0*iTime+2.*M_PI*a0; vec2 dp=vec2(cos(a),sin(a)); \n vec2 c = hash22(p0)*.5+.5*dp+p0-p;\n float d0 = dot(c,c);\n if (d0= 380. && iResolution.x < 440.) {\n red = -(iResolution.x - 440.) / (440. - 380.);\n green = 0.;\n blue = 1.;\n }\n else \n if (iResolution.x >= 440. && iResolution.x < 490.) {\n red = 0.;\n green = (iResolution.x - 440.) / (490. - 440.);\n blue = 1.;\n }\n else \n if (iResolution.x >= 490. && iResolution.x < 510.) {\n red = 0.;\n green = 1.;\n blue = -(iResolution.x - 510.) / (510. - 490.);\n }\n else \n if (iResolution.x >= 510. && iResolution.x < 580.) {\n red = (iResolution.x - 510.) / (580. - 510.);\n green = 1.;\n blue = 0.;\n }\n else \n if (iResolution.x >= 580. && iResolution.x < 645.) {\n red = 1.;\n green = -(iResolution.x - 645.) / (645. - 580.);\n blue = 0.;\n }\n else \n if (iResolution.x >= 645. && iResolution.x < 781.) {\n red = 1.;\n green = 0.;\n blue = 0.;\n }\n else {\n red = 0.;\n green = 0.;\n blue = 0.;\n }\n \n \n \n float factor;\n if (iResolution.x >= 380. && iResolution.x < 420.)\n factor = .3 + .7*(iResolution.x - 380.) / (420. - 380.);\n else \n if (iResolution.x >= 420. && iResolution.x < 701.)\n factor = 1.;\n else \n if (iResolution.x >= 701. && iResolution.x < 781.)\n factor = .3 + .7*(780. - iResolution.x) / (780. - 700.);\n else\n factor = 0.;\n \n float gamma = .8;\n float R = (red > 0. ? 255.*pow(red * factor, gamma) : 0.);\n float G = (green > 0. ? 255.*pow(green * factor, gamma) : 0.);\n float B = (blue > 0. ? 255.*pow(blue * factor, gamma) : 0.); \n \n return vec3(R/255.,G/255.,B/255.);\n \n }\n \n \n vec4 function_Trantor(in vec2 uv, in float t){\n \n float dist = length(uv);\n \n vec3 finalColor = vec3(0.0); \n \n for (float i=0.; i.5){\n ang.y *= -1.;\n } \n \n \n \n \n \n if(rnd3<.5) {\n d = d.yx;\n ang = ang.yx;\n }\n \n \n ang += .5;\n \n \n \n \n ang *= 3.;\n \n }\n else {\n \n \n \n \n \n if(rnd<.5) {\n p = p.yx*vec2(1, -1);\n }\n \n \n d.x = length(p - .5) - .5;\n d.y = length(p + .5) - .5;\n d = abs(d);\n \n \n \n \n \n ang.x = -atan(p.y - .5, p.x - .5);\n ang.y = -atan(p.y + .5, p.x + .5);\n \n \n \n \n \n if(mod(ip.x + ip.y, 2.)<.5) ang *= -1.;\n \n \n \n if(rnd<.5) ang *= -1.;\n \n \n \n \n if(rnd3<.5) {\n d = d.yx;\n ang = ang.yx;\n }\n \n \n \n \n \n ang *= 4./6.2831853;\n \n \n \n \n ang *= 2.;\n \n \n \n }\n \n \n \n \n ang = fract(ang + iTime/4.);\n \n \n return d;\n \n }\n \n \n float gridField(vec2 p){\n \n vec2 ip = floor(p);\n p -= ip + .5;\n \n p = abs(p);\n return abs(max(p.x, p.y) - .5) - .001;\n \n }\n \n half4 main(vec2 fragCoord) { \n \n \n vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n \n \n const float gSc = 7.;\n \n \n vec2 p = uv*gSc - vec2(-1, -.5)*iTime/4.;\n \n \n \n float sf = 2./iResolution.y*gSc;\n \n \n float lSc = 6.;\n \n lSc = 8.;\n \n \n \n float lw = 1./lSc/gSc;\n \n \n \n vec2 d = df(p) - 2.5/lSc;\n \n \n vec3 col = vec3(1., .9, .8);\n \n \n \n float pat = abs(fract(p.x*lSc + .5*0.) - .5) - lw*lSc/2.;\n col = mix(col, vec3(0), (1. - smoothstep(0., sf, pat)));\n \n \n \n \n \n for(int i = 0; i<2; i++){\n \n \n \n float di = d[i] - lw/4.;\n \n \n \n \n float tracks = clamp(sin(ang[i]*6.2831 + iTime*6.)*4., 0., 1.);\n \n \n \n \n float gap = 1. + lw;\n \n \n \n col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., di))*.35);\n col = mix(col, vec3(0), 1. - smoothstep(0., sf, di));\n \n \n col = mix(col, vec3(1., .9, .8), 1. - smoothstep(0., sf, di + lw*2.)); \n col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + gap/lSc));\n \n col = mix(col, vec3(1), 1. - smoothstep(0., sf, di + gap/lSc + lw));\n col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + 2.*gap/lSc));\n \n col = mix(col, vec3(1)*tracks, 1. - smoothstep(0., sf, di + 2.*gap/lSc + lw));\n \n \n }\n \n \n \n \n \n return vec4(sqrt(max(col, 0.)), 1);\n }"},{"id":"14","type":"trippy","code":"float mytanh(float x) {\n return (exp(2.0 * x) - 1.0) / (exp(2.0 * x) + 1.0);\n }\n float thc(float a, float b) {\n return mytanh(a * cos(b)) / mytanh(a);\n }\n \n vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n {\n return a + b*cos( 6.28318*(c*t+d) );\n }\n \n float h21 (vec2 a) {\n return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n }\n \n half4 main(vec2 fragCoord) { \n vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n float r = length(uv);\n \n \n \n float k = 10. + 8. * thc(3., r + iTime);\n float sc = 6. * ceil(k * fract(abs(uv.y) + r - 0.2 * iTime));\n float d = length(floor(sc * uv) + 0.5)/sc;\n float s = smoothstep(-1., 0.5, 0.1 + 0.5 * h21(uv));\n \n \n vec3 col = 1.1 * s * pal(d * 33333. + r - iTime * 0.1, \n vec3(1.), vec3(1.), vec3(1.), vec3(0.,0.33,0.66));\n \n return vec4(col,1.0);\n }"},{"id":"17","type":"relax","code":"vec3 p(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n return a + b * cos(6.28318 * (c * t + d));\n }\n \n vec3 sp(float t) {\n return p(t, vec3(0.26, 0.76, 0.77), vec3(1, 0.3, 1), vec3(0.8, 0.4, 0.7), vec3(0, 0.12, 0.54));\n }\n \n \n vec3 hue(float v) {\n return vec3(0.6 + 0.76 * cos(6.3 * v + vec4(0, 23, 21, 0)).xyz);\n }\n \n \n \n \n float hash12(vec2 p)\n {\n vec3 p3 = fract(vec3(p.xyx) * .1031);\n p3 += dot(p3, p3.yzx + 33.33);\n return fract((p3.x + p3.y) * p3.z);\n }\n \n vec2 hash22(vec2 p)\n {\n vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n p3 += dot(p3, p3.yzx+33.33);\n return fract((p3.xx+p3.yz)*p3.zy);\n }\n \n \n \n vec2 rotate2D(vec2 st, float a){\n return mat2(cos(a), -sin(a), sin(a), cos(a)) * st;\n }\n \n float st(float a, float b, float s) \n {\n return smoothstep(a - s, a + s, b);\n }\n \n float noise(in vec2 p) \n {\n vec2 i = floor(p);\n vec2 f = fract(p);\n \n vec2 u = f * f * (3. - 2. * f);\n \n return mix(mix(dot(hash22(i + vec2(0, 0)), f - vec2(0, 0)),\n dot(hash22(i + vec2(1, 0)), f - vec2(1, 0)), u.x),\n mix(dot(hash22(i + vec2(0, 1)), f - vec2(0, 1)),\n dot(hash22(i + vec2(1, 1)), f - vec2(1, 1)), u.x), u.y);\n }\n \n half4 main(vec2 fragCoord)\n {\n vec2 g = fragCoord;\n vec2 r = iResolution.xy;\n vec2 uv = (g + g - r) / r.y;\n uv.y = 0.0 - uv.y;\n vec2 sun_pos = vec2(r.x / r.y * .42, -.53); \n vec2 tree_pos = vec2(-r.x / r.y * .42, -.2); \n vec2 sh, u, id, lc, t;\n vec3 f, c;\n float xd, yd, h, a, l;\n half4 C;\n \n float sm = 3. / r.y; \n \n sh = rotate2D(sun_pos, noise(uv + iTime * .25) * .3); \n \n if (uv.y > -.4) \n {\n u = uv + sh;\n \n yd = 60.; \n \n id = vec2((length(u) + .01) * yd, 0); \n xd = floor(id.x) * .09; \n h = (hash12(floor(id.xx)) * .5 + .25) * (iTime + 10.) * .25; \n t = rotate2D(u, h); \n \n id.y = atan(t.y, t.x) * xd;\n lc = fract(id); \n id -= lc;\n \n \n t = vec2(cos((id.y + .5) / xd) * (id.x + .5) / yd, sin((id.y + .5) / xd) * (id.x + .5) / yd);\n t = rotate2D(t, -h) - sh;\n \n h = noise(t * vec2(.5, 1) - vec2(iTime * .2, 0)); \n h = step(-.25, t.y) * h; \n h = smoothstep(.052, .055, h);\n \n lc += (noise(lc * vec2(1, 4) + id)) * vec2(.7, .2); \n \n f = mix(sp(sin(length(u) - .1)) * .35, \n mix(sp(sin(length(u) - .1) + (hash12(id) - .5) * .15), vec3(1), h), \n st(abs(lc.x - .5), .4, sm * yd) * st(abs(lc.y - .5), .48, sm * xd));\n };\n \n if (uv.y < -.35) \n {\n \n float cld = noise(-sh * vec2(.5, 1) - vec2(iTime * .2, 0)); \n cld = 1. - smoothstep(.0, .15, cld) * .5;\n \n u = uv * vec2(1, 15);\n id = floor(u);\n \n for (float i = 1.; i > -1.; i--) \n {\n if (id.y + i < -5.)\n {\n lc = fract(u) - .5;\n lc.y = (lc.y + (sin(uv.x * 12. - iTime * 3. + id.y + i) * .25 - i)) * 4.; \n h = hash12(vec2(id.y + i, floor(lc.y))); \n \n xd = 6. + h * 4.;\n yd = 30.;\n lc.x = uv.x * xd + sh.x * 9.; \n lc.x += sin(iTime * (.5 + h * 2.)) * .5; \n h = .8 * smoothstep(5., .0, abs(floor(lc.x))) * cld + .1; \n f = mix(f, mix(vec3(0, .1, .5), vec3(.35, .35, 0), h), st(lc.y, 0., sm * yd)); \n lc += noise(lc * vec2(3, .5)) * vec2(.1, .6); \n \n f = mix(f, \n mix(hue(hash12(floor(lc)) * .1 + .56).rgb * (1.2 + floor(lc.y) * .17), vec3(1, 1, 0), h) \n , st(lc.y, 0., sm * xd) * st(abs(fract(lc.x) - .5), .48, sm * xd) * st(abs(fract(lc.y) - .5), .3, sm * yd)\n );\n }\n }\n }\n \n half4 O = half4(f, 1);\n \n \n a = 0.;\n u = uv + noise(uv * 2.) * .1 + vec2(0, sin(uv.x * 1. + 3.) * .4 + .8);\n \n f = mix(vec3(.7, .6, .2), vec3(0, 1, 0), sin(iTime * .2) * .5 + .5); \n O = mix(O, half4(f * .4, 1), step(u.y, .0)); \n \n xd = 60.; \n u = u * vec2(xd, xd / 3.5);\n \n if (u.y < 1.2)\n {\n for (float y = 0.; y > -3.; y--)\n {\n for (float x = -2.; x < 3.; x++)\n {\n id = floor(u) + vec2(x, y);\n lc = (fract(u) + vec2(1. - x, -y)) / vec2(5, 3);\n h = (hash12(id) - .5) * .25 + .5; \n \n lc -= vec2(.3, .5 - h * .4);\n lc.x += sin(((iTime * 1.7 + h * 2. - id.x * .05 - id.y * .05) * 1.1 + id.y * .5) * 2.) * (lc.y + .5) * .5;\n t = abs(lc) - vec2(.02, .5 - h * .5);\n l = length(max(t, 0.)) + min(max(t.x, t.y), 0.); \n \n l -= noise(lc * 7. + id) * .1; \n C = half4(f * .25, st(l, .1, sm * xd * .09)); \n C = mix(C, half4(f \n * (1.2 + lc.y * 2.) \n * (1.8 - h * 2.5), 1.) \n , st(l, .04, sm * xd * .09));\n \n O = mix(O, C, C.a * step(id.y, -1.));\n a = max(a, C.a * step(id.y, -5.)); \n }\n }\n }\n \n float T = sin(iTime * .5); \n \n if (abs(uv.x + tree_pos.x - .1 - T * .1) < .6) \n {\n u = uv + tree_pos;\n \n u.x -= sin(u.y + 1.) * .2 * (T + .75); \n u += noise(u * 4.5 - 7.) * .25; \n \n xd = 10., yd = 60.;\n t = u * vec2(1, yd); \n h = hash12(floor(t.yy)); \n t.x += h * .01;\n t.x *= xd;\n \n lc = fract(t); \n \n float m = st(abs(t.x - .5), .5, sm * xd) * step(abs(t.y + 20.), 45.); \n C = mix(half4(.07) \n , half4(.5, .3, 0, 1) * (.4 + h * .4) \n , st(abs(lc.y - .5), .4, sm * yd) * st(abs(lc.x - .5), .45, sm * xd));\n C.a = m;\n \n xd = 30., yd = 15.;\n \n for (float xs = 0.; xs < 4.; xs++) \n {\n u = uv + tree_pos + vec2(xs / xd * .5 - (T + .75) * .15, -.7); \n u += noise(u * vec2(2, 1) + vec2(-iTime + xs * .05, 0)) * vec2(-.25, .1) * smoothstep(.5, -1., u.y + .7) * .75; \n \n t = u * vec2(xd, 1.);\n h = hash12(floor(t.xx) + xs * 1.4); \n \n yd = 5. + h * 7.;\n t.y *= yd;\n \n sh = t;\n lc = fract(t);\n h = hash12(t - lc); \n \n t = (t - lc) / vec2(xd, yd) + vec2(0, .7);\n \n m = (step(0., t.y) * step(length(t), .45) \n + step(t.y, 0.) * step(-0.7 + sin((floor(u.x) + xs * .5) * 15.) * .2, t.y)) \n * step(abs(t.x), .5) \n * st(abs(lc.x - .5), .35, sm * xd * .5);\n \n lc += noise((sh) * vec2(1., 3.)) * vec2(.3, .3); \n \n f = hue((h + (sin(iTime * .2) * .5 + .5)) * .2).rgb - t.x; \n \n C = mix(C,\n half4(mix(f * .15, f * .6 * (.7 + xs * .2), \n st(abs(lc.y - .5), .47, sm * yd) * st(abs(lc.x - .5), .2, sm * xd)), m)\n , m);\n }\n \n O = mix(O, C, C.a * (1. - a));\n }\n \n return O;\n }\n "},{"id":"18","type":"loop","code":"float vDrop(vec2 uv,float t)\n {\n uv.x = uv.x*128.0;\t\t\t\t\t\t\n float dx = fract(uv.x);\n uv.x = floor(uv.x);\n uv.y *= 0.05;\t\t\t\t\t\t\t\n float o=sin(uv.x*215.4);\t\t\t\t\n float s=cos(uv.x*33.1)*.3 +.7;\t\t\t\n float trail = mix(95.0,35.0,s);\t\t\t\n float yv = fract(uv.y + t*s + o) * trail;\n yv = 1.0/yv;\n yv = smoothstep(0.0,1.0,yv*yv);\n yv = sin(yv*M_PI)*(s*5.0);\n float d2 = sin(dx*M_PI);\n return yv*(d2*d2);\n }\n \n \n half4 main(vec2 fragCoord) { \n vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n float d = length(p)+exp(-iTime)*0.9+0.1;\n p = vec2(atan(p.x, p.y) / M_PI, 2.5 / d);\n float t = iTime*0.4;\n vec3 col = vec3(1.55,0.65,.225) * vDrop(p,t);\t\n col += vec3(0.55,0.75,1.225) * vDrop(p,t+0.33);\t\n col += vec3(0.45,1.15,0.425) * vDrop(p,t+0.66);\t\n return vec4(col*(d*d), 1.0);\n }\n "},{"id":"19","type":"loop","code":"const int MAX_DIST = 128;\n\n\n vec3 rotTransform(vec3 v, vec4 R) {\n vec3 uv = cross(R.yzx, v);\n \n return v + 2.0 * (R.w * uv + cross(R.yzx, uv));\n \n }\n \n \n \n float distBox(vec3 p, float r) {\n vec3 p1 = abs(p);\n float d = length(max(p1-r, 0.));\n float dsigned = min(max(max(p1.x-r, p1.y-r), p1.z-r), 0.);\n return d + dsigned;\n }\n \n float distSphere(vec3 p, float r) {\n return length(p) - r;\n }\n \n float distScene(vec3 p) {\n float t = cos(iTime)+5.;\n vec3 p1 = mod(p+t/2., t) - t/2.;\n vec3 p2 = rotTransform(p1, vec4(sin(iTime/2.)*normalize(vec3(0.5, -0.5, 1)), cos(iTime/2.)));\n return max(distBox(p2, 1.), -distSphere(p2, 1.3));\n }\n \n float rayMarch(vec3 pos, vec3 rd) {\n float d = 0.0;\n \n for (int i = 0; i < MAX_DIST; i++) {\n vec3 p = pos + rd * d;\n float ds = distScene(p);\n \n if (ds <= 0.001) {\n break;\n }\n \n d += ds;\n }\n \n return d;\n }\n \n vec3 getNormal(vec3 p) {\n vec2 e = vec2(.001, 0);\n float d = distScene(p);\n vec3 n = d-vec3(distScene(p-e.xyy), distScene(p-e.yxy), distScene(p-e.yyx));\n return normalize(n);\n }\n \n vec3 render(vec3 campos, vec4 camrot, float fov, vec2 coord) {\n vec3 raydir = rotTransform(normalize(vec3(coord.x, fov, coord.y)), camrot);\n float d = rayMarch(campos, raydir);\n if (int(d) >= MAX_DIST) { return vec3(0); }\n vec3 p = campos + raydir * d;\n \n vec3 n = getNormal(p);\n return vec3(n.x/2. + 0.5, n.y/2. + 0.5, n.z/2. + 0.5);\n }\n \n \n half4 main(vec2 fragCoord) { \n \n vec2 uv = (fragCoord-iResolution.xy/2.)*2./iResolution.yy;\n \n vec3 campos = vec3(0);\n vec4 camrot = vec4(sin(iTime/2.)*normalize(vec3(1, 1, 1)), cos(iTime/2.));\n \n vec3 col = render(campos, camrot, 1.5, uv);\n \n return vec4(col, 1);\n }"},{"id":"21","type":"trippy","code":"const float PI = 3.141592654; const float TAU = (2.0 * PI); \n\n float L2(vec3 x) {\n return dot(x, x);\n }\n \n mat2 ROT(float a) {\n return mat2(cos(a), sin(a), -sin(a), cos(a));\n }\n \n \n float PSIN(float x) {\n return (0.5 + 0.5 * sin(x));\n }\n \n float myTanh(float x) {\n return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n }\n \n vec3 hsv2rgb(vec3 c) {\n const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n }\n \n float apollian(vec4 p, float s) {\n float scale = 1.0;\n \n for(int i=0; i<7; ++i) {\n p = -1.0 + 2.0*fract(0.5*p+0.5);\n \n float r2 = dot(p,p);\n \n float k = s/r2;\n p *= k;\n scale *= k;\n }\n \n return abs(p.y)/scale;\n }\n \n float weird(vec2 p) {\n float z = 4.0;\n p *= ROT(iTime*0.1);\n float tm = 0.2*iTime;\n float r = 0.5;\n vec4 off = vec4(r*PSIN(tm*sqrt(3.0)), r*PSIN(tm*sqrt(1.5)), r*PSIN(tm*sqrt(2.0)), 0.0);\n vec4 pp = vec4(p.x, p.y, 0.0, 0.0)+off;\n pp.w = 0.125*(1.0-myTanh(length(pp.xyz)));\n pp.yz *= ROT(tm);\n pp.xz *= ROT(tm*sqrt(0.5));\n pp /= z;\n float d = apollian(pp, 1.2);\n return d*z;\n }\n \n float df(vec2 p) {\n const float zoom = 0.5;\n p /= zoom;\n float d0 = weird(p);\n return d0*zoom;\n }\n \n vec3 color(vec2 p) {\n float aa = 2.0/iResolution.y;\n const float lw = 0.0235;\n const float lh = 1.25;\n \n const vec3 lp1 = vec3(0.5, lh, 0.5);\n const vec3 lp2 = vec3(-0.5, lh, 0.5);\n \n float d = df(p);\n \n float b = -0.125;\n float t = 10.0;\n \n vec3 ro = vec3(0.0, t, 0.0);\n vec3 pp = vec3(p.x, 0.0, p.y);\n \n vec3 rd = normalize(pp - ro);\n \n vec3 ld1 = normalize(lp1 - pp);\n vec3 ld2 = normalize(lp2 - pp);\n \n float bt = -(t-b)/rd.y;\n \n vec3 bp = ro + bt*rd;\n vec3 srd1 = normalize(lp1-bp);\n vec3 srd2 = normalize(lp2-bp);\n float bl21= L2(lp1-bp);\n float bl22= L2(lp2-bp);\n \n float st1= (0.0-b)/srd1.y;\n float st2= (0.0-b)/srd2.y;\n vec3 sp1 = bp + srd1*st1;\n vec3 sp2 = bp + srd2*st1;\n \n float bd = df(bp.xz);\n float sd1= df(sp1.xz);\n float sd2= df(sp2.xz);\n \n vec3 col = vec3(0.0);\n const float ss =15.0;\n \n col += vec3(1.0, 1.0, 1.0)*(1.0-exp(-ss*(max((sd1+0.0*lw), 0.0))))/bl21;\n col += vec3(0.5)*(1.0-exp(-ss*(max((sd2+0.0*lw), 0.0))))/bl22;\n float l = length(p);\n float hue = fract(0.75*l-0.3*iTime)+0.3+0.15;\n float sat = 0.75*myTanh(2.0*l);\n vec3 hsv = vec3(hue, sat, 1.0);\n vec3 bcol = hsv2rgb(hsv);\n col *= (1.0-myTanh(0.75*l))*0.5;\n col = mix(col, bcol, smoothstep(-aa, aa, -d)); \n col += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*myTanh(l))*max(d, 0.0)));\n \n return col;\n }\n \n vec3 postProcess(vec3 col, vec2 q) {\n col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n col=col*0.6+0.4*col*col*(3.0-2.0*col); \n col=mix(col, vec3(dot(col, vec3(0.33))), -0.4); \n col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7); \n return col;\n }\n \n half4 main(vec2 fragCoord) { \n vec2 q = fragCoord/iResolution.xy;\n vec2 p = -1. + 2. * q;\n p.x *= iResolution.x/iResolution.y;\n \n vec3 col = color(p);\n col = postProcess(col, q);\n \n return vec4(col, 1.0);\n }"},{"id":"22","type":"loop","code":"const float \n sqr2 = 1.4142135623730950488016887242096980785696, \n sqr3 = 1.7320508075688772935274463415058723669428, \n sqr2_inv = 1.0/sqr2 ,\n sqr3_inv = 1.0/sqr3 ,\n l = 0.35, \n l_inv = 1.0/l ,\n line_w = 0.02 ; \n \n const vec2 \n u = 1.0*vec2( 1.0, 0.0 ) ,\n v = 0.5*vec2( 1.0, sqr3 ) ,\n u_dual = 1.0*vec2( 1.0, -sqr3_inv ) ,\n v_dual = 2.0*vec2( 0.0, sqr3_inv ) ,\n tri_cen = vec2( 0.5, 0.5*sqr3_inv ) ; \n \n vec2\n center ; \n \n float \n mind ; \n \n \n \n \n \n \n vec2 mirror( vec2 p, vec2 v1, vec2 v2 )\n {\n vec2 s = v2-v1 ,\n n = normalize(vec2( s.y, -s.x )) ;\n float d = dot(p-v1,n) ;\n \n return p-max(0.0,2.0*d)*n ;\n }\n \n \n float dist( vec2 p, vec2 v1, vec2 v2 )\n {\n vec2 s = v2-v1 ,\n n = normalize(vec2( s.y, -s.x )) ;\n return dot(p-v1,n) ;\n }\n \n \n vec2 p6mm_ToFundamental( vec2 p0 ) \n {\n \n \n vec2 p1 = p0*mat2( u_dual, v_dual ); \n \n \n \n vec2 p2 = fract(p1); \n \n \n \n \n vec2 p3 = mirror( p2, vec2(1.0,0.0), vec2(0.0,1.0) );\n \n \n \n vec2 p4 = p3.x*u + p3.y*v ;\n \n \n \n vec2 p5 = mirror( p4, vec2(0.5,0.0), tri_cen );\n vec2 p6 = mirror( p5, vec2(1.0,0.0), tri_cen );\n vec2 p7 = mirror( p6, tri_cen, vec2(0.0,0.0) );\n \n return p7 ;\n }\n \n \n \n float DistanceFunc( float d )\n {\n \n return smoothstep( line_w*1.15, line_w*0.85, d ); \n }\n \n \n \n vec4 p6mm_SimmetryLines( vec2 p_ndc )\n {\n \n vec2 pf = p6mm_ToFundamental( p_ndc );\n \n float d1 = abs(pf.y),\n d2 = abs(pf.x-0.5),\n d3 = abs( dist( pf, tri_cen, vec2(0.0,0.0) ) );\n \n vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 ) ;\n \n res.r = DistanceFunc(d2);\n res.g = DistanceFunc(d1);\n res.b = DistanceFunc(d3);\n \n return res ; \n }\n \n \n vec2 DCToNDC( vec2 p_dc )\n {\n return l_inv*(p_dc - center)/mind ;\n }\n \n \n vec2 Inversion( vec2 p, vec2 cen )\n {\n const float speedFactor = 5.0 ;\n float secs = iTime*speedFactor ;\n vec2 vr = p-cen ; \n return cen + vr/dot(vr,vr)*10.0 \n + secs/4.0*vec2(1.0,0.5) ;\n }\n \n \n \n \n half4 main(vec2 fragCoord) { \n const int n = 9;\n \n center = 0.5*2.5*iResolution.xy ; \n mind = min(iResolution.x,iResolution.y);\n \n vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 );\n \n vec2 mou = DCToNDC( iResolution.xy/2 );\n \n for (int ix = 0 ; ix < n ; ix += 1 )\n for (int iy = 0 ; iy < n ; iy += 1 )\n {\n float px = -0.5 + (0.5+float(ix))/float(n), \n py = -0.5 + (0.5+float(iy))/float(n) ;\n \n vec2 pNDC = DCToNDC( fragCoord + vec2( px, py ) );\n \n vec2 pinv = Inversion( pNDC, mou ) ;\n \n res += p6mm_SimmetryLines( pinv );\n }\n \n return res/(float(n)*float(n)) ; \n }\n "},{"id":"23","type":"trippy","code":"float rand(float n){return fract(sin(n) * 43758.5453123);}\n float rand(vec2 n){return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n float noise(float p){\n float fl = floor(p);\n float fc = fract(p);\n return mix(rand(fl), rand(fl + 1.0), fc);\n }\n \n \n vec3 hsv2rgb(vec3 c)\n {\n vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n }\n \n float manh_distance(vec2 a, vec2 b) {\n vec2 c = abs(a - b);\n return c.x + c.y;\n }\n \n float pyramids(vec2 p)\n {\n vec2 n = floor(p);\n vec2 f = fract(p);\n float mind = 2.0;\n for (int i=-1;i<2;i++)\n for (int j=-1;j<2;j++)\n {\n vec2 off = vec2(i,j);\n vec2 top = vec2( rand(n+off), rand(n+off+234.1) );\n float dist = manh_distance(f,top+off);\n if (dist < mind) {\n mind = dist;\n }\n }\n return (2.0 - mind) / 2.0;\n }\n \n float SQ3 = 1.7320508076;\n \n mat2 rot2d(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n \n vec2 p6mmmap(vec2 uv, float repeats) {\n \n uv.x /= SQ3;\n uv = fract(uv * repeats - 0.5) - 0.5;\n uv.x *= SQ3;\n \n uv = abs(uv);\n \n vec2 st = uv;\n \n vec2 uv330 = rot2d(radians(330.)) * uv;\n if (uv330.x < 0.0){\n st.y = (st.y - 0.5) * -1.0;\n st.x *= SQ3;\n return st * 2.0;\n }\n else if (uv330.x > 0.5){\n st.x = (st.x - 0.5 * SQ3) * -1.0 * SQ3;\n return st * 2.0;\n }\n \n vec2 uv30 = rot2d(radians(30.)) * uv;\n if (uv30.y < 0.0 && uv30.x >= 0.5) st = vec2(1.0,1.0);\n else if (uv30.y >= 0.0 && uv30.x >= 0.5) st = vec2(-1.0,1.0);\n else if (uv30.y < 0.0 && uv30.x < 0.5) st = vec2(1.0,-1.0);\n else st = vec2(-1.0,-1.0);\n \n uv30.x = uv30.x - 0.5;\n uv = rot2d(radians(270.))* uv30;\n st = uv * st;\n st.x *= SQ3;\n return st * 2.0;\n }\n \n float uc(float a) { return clamp(a,0.,1.); }\n float ns(float a, float t) { return noise(a+t); }\n \n vec3 square_noise(vec2 uv, float t) {\n \n float p1 = ns(pyramids(uv)*15.,t);\n float p2 = ns(pyramids(uv+135.)*31.,t);\n float p3 = ns(pyramids(uv+25.)*63.,t);\n \n float v = uc((p1*p2*p3-0.09)*41.);\n \n vec3 res = hsv2rgb(vec3(uc(uc(p3)-0.2),uc(uc(p2)-0.2),v));\n \n return res;\n }\n \n vec4 animate_noise(vec2 uv, float t) {\n return vec4(square_noise((rot2d(radians(t*12.7))*(uv-0.25)+0.25)+t*0.06,t*0.2),1.0);\n }\n \n \n half4 main(vec2 fragCoord) { \n \n vec2 uv = fragCoord / iResolution.xy - 0.5;\n uv.x *= iResolution.x/iResolution.y;\n uv *= iResolution.x / 2000.0;\n \n uv = p6mmmap(uv,2.) * 0.65;\n \n float t = floor(0/10.)*4.+4.*iResolution.x/10.*floor(0/10.)-100000.;\n return animate_noise(uv,t>-100000. ? t : iTime);\n }"}])
});
app.get('/playlist', async (req, res, next) => {
  const data = [
    {"id": "1", "title": "video de prueba", "desc": "esto es un video de prueba", "url": "http://192.168.3.14:5555/videos/VID_20230705_210345.mp4"},
    {"id": "4", "title": "video de prueba", "desc": "esto es un video de prueba", "url": "http://192.168.3.14:5555/videos/VID_20230718_194307~2.mp4"},
    { "id": "5", "title": "video de prueba", "desc": "esto es un video de prueba", "url": "http://192.168.3.14:5555/videos/VID_20230722_233955.mp4"},
    { "id": "7", "title": "video de prueba", "desc": "esto es un video de prueba", "url": "http://192.168.3.14:5555/videos/VID_20230722_234731.mp4"},


  ]
  res.send(data);
});

// Serve static files (videos) from the "uploads" directory
app.use('/videos', express.static('uploads'));

app.put('/upload-full', async (req, res) => {
  const contentDisposition = req.headers['content-disposition'];
  const filenameRegex = /filename="([^"]+)"/;
  const matches = contentDisposition.match(filenameRegex);
  const filename = matches[1];

  try {
    let fileSize = 0;
    const filePath = 'uploads/' + filename;
    const writeStream = fs.createWriteStream(filePath);

    req.on('data', (chunk) => {
      fileSize += chunk.length; // Incrementa el tamaño del archivo
      writeStream.write(chunk); // Escribe los fragmentos de datos en el archivo
    });

    req.on('end', () => {
      writeStream.end(); // Finaliza la escritura en el archivo
      console.log('fileSize', fileSize);
      console.log('filePath', filePath);
      res.status(200).json({ message: 'Archivo subido exitosamente' });
    });
  } catch (err) {
    res.status(500).send(err);
  }
});


app.put('/upload-corta', async (req, res) => {
  const contentDisposition = req.headers['content-disposition'];
  const filenameRegex = /filename="([^"]+)"/;
  const matches = contentDisposition.match(filenameRegex);
  const filename = matches[1];

  try {
    let fileSize = 0;
    const filePath = 'uploads/' + filename;
    const writeStream = fs.createWriteStream(filePath);

    req.on('data', (chunk) => {
      fileSize += chunk.length; // Incrementa el tamaño del archivo

      if (fileSize > MAX_FILE_SIZE * 1024 * 1024) { // Verifica el tamaño límite (10 megabytes)
        writeStream.end(); // Finaliza la escritura en el archivo

        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
        }

        res.status(413).json({ message: 'El tamaño del archivo excede el límite permitido' });
        req.destroy(); // Termina la solicitud para evitar que siga subiendo el archivo
      } else {
        writeStream.write(chunk); // Escribe los fragmentos de datos en el archivo
      }
    });

    req.on('end', () => {
      writeStream.end(); // Finaliza la escritura en el archivo

      if (fileSize <= MAX_FILE_SIZE * 1024 * 1024) { // Verifica el tamaño límite (10 megabytes)
        res.status(200).json({ message: 'Archivo subido exitosamente' });
      }
    });
  } catch (err) {
    res.status(500).send(err);
  }
});


app.put('/upload-ios', async (req, res) => {

  const contentDisposition = req.headers['content-disposition'];
  const filenameRegex = /filename="([^"]+)"/;
  const matches = contentDisposition.match(filenameRegex);
  const filename = matches[1];

  console.log('filename', filename);
  console.log('req', req);
  try {
    const writeStream = fs.createWriteStream('uploads/'+filename);

    req.on('data', (chunk) => {
      console.log('chunk', chunk);
      writeStream.write(chunk); // Escribe los fragmentos de datos en el archivo
    });
  
    req.on('end', () => {
      console.log('end', writeStream);
      writeStream.end(); // Finaliza la escritura en el archivo
  
      res.status(200).json({ message: 'Archivo subido exitosamente' });
    });    

  } catch (err) {
      res.status(500).send(err);
  }
});

//app.listen(PORT, '192.168.3.14', () => {
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
